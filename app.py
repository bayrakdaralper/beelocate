from flask import Flask, render_template, request, jsonify, send_file
from flask_caching import Cache
import osmnx as ox
import geopandas as gpd
from shapely.geometry import Point
import pandas as pd
from fpdf import FPDF
import requests
import numpy as np
import io
import traceback
from datetime import datetime
from math import sqrt, atan2, degrees, pi
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import tempfile
import os

app = Flask(__name__)
# Basit Cache (Hız için)
cache = Cache(app, config={'CACHE_TYPE': 'SimpleCache', 'CACHE_DEFAULT_TIMEOUT': 600})

# --- DİL VE METİN AYARLARI (GÜNCELLENDİ) ---
TRANS = {
    'TR': {
        'title': 'ARICILIK SAHA ANALIZ RAPORU', 'score': 'SKOR', 
        'high': 'YUKSEK POTANSIYEL', 'med': 'ORTA/RISKLI BOLGE',
        'ch_1': '1. YONETICI OZETI', 'ch_2': '2. TEKNIK DETAYLAR',
        'loc': 'Konum', 'flora': 'Flora Tipi', 'water': 'Su Kaynagi', 
        'wind': 'Hakim Ruzgar', 'aspect': 'Arazi Bakisi', 'temp': 'Ort. Sicaklik',
        'elev': 'Rakim', 'settle': 'Yerlesim', 'access': 'Ulasim',
        'not_found': 'Veri Yok', 'access_err': 'Erisim Zor / Uzak',
        
        # YENİ SU METİNLERİ
        'w_good': "Su kaynaklarina erisim ideal seviyededir",
        'w_bad': "Su kaynagi uzaktir, tasima su gerekebilir",
        'w_crit': "KRITIK: Dogal su kaynagi erisim disindadir (>5km). Su takviyesi zorunludur.",
        
        'wi_warn': "DIKKAT: Ruzgar hizi ({spd} km/h) yuksektir",
        'std_summary': "Bölgede <b>{flora}</b> hakimiyeti görülmüştür. Hakim rüzgar <b>{wind}</b> yönündedir. {water_txt}. {wind_txt}",
        'err_summary': "Bölgede baskın bitki örtüsü uydu verileriyle ayırt edilememiştir. Ancak yapılaşma düşüktür. Hakim rüzgar <b>{wind}</b> yönündedir. {water_txt}.",
        'footer': 'Bu rapor BeeLocate algoritmaları ile otomatik oluşturulmuştur.'
    },
    'EN': {
        'title': 'BEEKEEPING SITE ANALYSIS REPORT', 'score': 'SCORE', 
        'high': 'HIGH POTENTIAL', 'med': 'MEDIUM/RISKY',
        'ch_1': '1. EXECUTIVE SUMMARY', 'ch_2': '2. TECHNICAL DETAILS',
        'loc': 'Location', 'flora': 'Flora Type', 'water': 'Water Source', 
        'wind': 'Prevailing Wind', 'aspect': 'Aspect', 'temp': 'Avg. Temp',
        'elev': 'Elevation', 'settle': 'Settlement', 'access': 'Access',
        'not_found': 'Not Detected', 'access_err': 'Hard Access / Far',
        
        'w_good': "Access to water sources is ideal",
        'w_bad': "Water source is distant",
        'w_crit': "CRITICAL: Natural water source out of range (>5km). Supplement required.",
        
        'wi_warn': "WARNING: Wind speed ({spd} km/h) is high",
        'std_summary': "Area dominated by <b>{flora}</b>. Prevailing wind is <b>{wind}</b>. {water_txt}. {wind_txt}",
        'err_summary': "Dominant vegetation could not be distinguished. However, urbanization is low. Prevailing wind is <b>{wind}</b>. {water_txt}.",
        'footer': 'This report was automatically generated by BeeLocate algorithms.'
    }
}

def tr_chars(text):
    replacements = {'ğ':'g', 'Ğ':'G', 'ü':'u', 'Ü':'U', 'ş':'s', 'Ş':'S', 'ı':'i', 'İ':'I', 'ö':'o', 'Ö':'O', 'ç':'c', 'Ç':'C'}
    for k, v in replacements.items(): text = str(text).replace(k, v)
    return text

def translate_dir(code, lang="TR"):
    tr = {"N": "Kuzey", "NE": "Kuzeydogu", "E": "Dogu", "SE": "Guneydogu", "S": "Guney", "SW": "Guneybati", "W": "Bati", "NW": "Kuzeybati"}
    en = {"N": "North", "NE": "Northeast", "E": "East", "SE": "Southeast", "S": "South", "SW": "Southwest", "W": "West", "NW": "Northwest"}
    return tr.get(code, code) if lang == "TR" else en.get(code, code)

def degree_to_dir_code(deg):
    val = int((deg/22.5) + .5)
    arr = ["N", "NE", "NE", "E", "E", "SE", "SE", "S", "S", "SW", "SW", "W", "W", "NW", "NW", "N"]
    return arr[(val % 16)]

def create_radar_chart(scores):
    try:
        labels = ['Flora', 'Su', 'Ruzgar', 'Baki', 'Sicaklik', 'Ulasim', 'Yerlesim', 'Egim']
        stats = [scores['flora'], scores['water'], scores['wind'], scores['aspect'], scores['temp'], scores['road'], scores['build'], scores['slope']]
        stats += stats[:1]
        angles = np.linspace(0, 2*pi, len(labels), endpoint=False).tolist()
        angles += angles[:1]
        fig, ax = plt.subplots(figsize=(6, 6), subplot_kw=dict(polar=True))
        ax.fill(angles, stats, color='#FFC107', alpha=0.25)
        ax.plot(angles, stats, color='#FFC107', linewidth=2)
        ax.set_yticklabels([])
        ax.set_xticks(angles[:-1])
        ax.set_xticklabels(labels, size=9, color="grey")
        ax.spines['polar'].set_visible(False)
        ax.grid(color='grey', alpha=0.3)
        tmp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.png')
        plt.savefig(tmp_file.name, transparent=True, dpi=100)
        plt.close()
        return tmp_file.name
    except: return None

def get_meteo_extended(lat, lng):
    try:
        url = f"https://api.open-meteo.com/v1/forecast?latitude={lat}&longitude={lng}&current=temperature_2m&daily=temperature_2m_max,relative_humidity_2m_mean,wind_speed_10m_max,winddirection_10m_dominant,sunrise,sunset&timezone=auto&forecast_days=7"
        r = requests.get(url, timeout=4).json()
        d = r.get('daily', {}); c = r.get('current', {})
        return {
            'cur_temp': c.get('temperature_2m', 0),
            'avg_temp': round(np.mean(d.get('temperature_2m_max', [20])), 1),
            'avg_wind': round(np.mean(d.get('wind_speed_10m_max', [5])), 1),
            'avg_hum': int(np.mean(d.get('relative_humidity_2m_mean', [50]))),
            'wind_dir': d.get('winddirection_10m_dominant', [0])[0]
        }
    except: return {'cur_temp':20, 'avg_temp':20, 'avg_wind':5, 'wind_dir':0, 'avg_hum':50}

def get_terrain_pro(lat, lng):
    try:
        url = f"https://api.open-meteo.com/v1/elevation?latitude={lat},{lat+0.001},{lat}&longitude={lng},{lng},{lng+0.001}"
        e = requests.get(url, timeout=3).json().get('elevation', [0,0,0])
        dz_dx, dz_dy = (e[2]-e[0])/90, (e[1]-e[0])/90
        s_rad = atan2(sqrt(dz_dx**2 + dz_dy**2), 1)
        asp = degrees(atan2(dz_dy, -dz_dx)); asp = asp+360 if asp<0 else asp
        dirs = ["E", "NE", "N", "NW", "W", "SW", "S", "SE"]
        return abs(np.tan(s_rad)*100), degrees(s_rad), dirs[int((asp+22.5)/45)%8], int(e[0])
    except: return 0, 0, "N", 0

def calculate_score(lat, lng, radius=2000, lang="TR"):
    cache_key = f"stable_score_{round(lat,4)}_{round(lng,4)}_{radius}_{lang}"
    cached = cache.get(cache_key)
    if cached: return cached

    tags = {'natural':['water','wood','scrub','grassland'], 'waterway':True, 'landuse':['forest','orchard','farmland','meadow','grass'], 'building':True, 'highway':['motorway','primary','secondary']}
    
    try: 
        ox.settings.timeout = 20
        gdf = ox.features_from_point((lat, lng), tags, dist=1500)
    except: gdf = gpd.GeoDataFrame()
    
    p = Point(lng, lat); f=gpd.GeoDataFrame(); w=gpd.GeoDataFrame(); b=gpd.GeoDataFrame(); r=gpd.GeoDataFrame()
    if not gdf.empty:
        if 'natural' in gdf.columns: f = pd.concat([f, gdf[gdf['natural'].isin(['wood','scrub','grassland'])]])
        if 'landuse' in gdf.columns: f = pd.concat([f, gdf[gdf['landuse'].isin(['forest','orchard','farmland','meadow','grass'])]])
        if 'natural' in gdf.columns: w = pd.concat([w, gdf[gdf['natural']=='water']])
        if 'waterway' in gdf.columns: w = pd.concat([w, gdf[gdf['waterway'].notna()]])
        if 'building' in gdf.columns: b = gdf[gdf['building'].notna()]
        if 'highway' in gdf.columns: r = gdf[gdf['highway'].notna()]

    meteo = get_meteo_extended(lat, lng)
    slope_pct, slope_deg, aspect_dir, elevation = get_terrain_pro(lat, lng)

    d_flora = 9999; flora_name = "Bilinmiyor" if lang=="TR" else "Unknown"
    if not f.empty:
        d_flora = f.distance(p).min()*111000
        near = f.iloc[f.distance(p).argmin()]
        ts = str(near.get('natural',''))+str(near.get('landuse',''))
        if "wood" in ts or "forest" in ts: flora_name = "Orman"
        elif "meadow" in ts or "grass" in ts: flora_name = "Mera"
        elif "farm" in ts: flora_name = "Tarim"
        else: flora_name = "Calilik"
    
    s_f = 100 if d_flora < 100 else max(0, 100-(d_flora/2000)*100)
    if "Tarim" in flora_name: s_f *= 0.7
    
    asp_sc = {'S':100,'SE':100,'SW':90,'E':80,'W':50,'NE':30,'NW':20,'N':10}
    s_a = asp_sc.get(aspect_dir, 50)
    s_w = 100 if meteo['avg_wind']<15 else max(0, 100-(meteo['avg_wind']-15)*5)
    s_t = 100 if 15<=meteo['avg_temp']<=30 else 50
    cnt = len(b); s_b = 100 if cnt < 10 else max(0, 100-cnt*1.5)
    dw = w.distance(p).min()*111000 if not w.empty else 9999
    s_wt = 0 if dw > 3000 else (100 if dw<1000 else max(0, 100-(dw/3000)*100))
    s_sl = 100 if 0<=slope_pct<=30 else 20
    dr = r.distance(p).min()*111000 if not r.empty else 9999
    s_r = 100 if 200<dr<3000 else 40
    
    total = (s_f*0.35)+(s_a*0.10)+(s_w*0.10)+(s_t*0.05)+(s_b*0.10)+(s_wt*0.15)+(s_sl*0.05)+(s_r*0.10)
    wind_code = degree_to_dir_code(meteo['wind_dir'])

    subs = {'flora': int(s_f), 'aspect': int(s_a), 'wind': int(s_w), 'temp': int(s_t), 'build': int(s_b), 'water': int(s_wt), 'slope': int(s_sl), 'road': int(s_r)}
    dets = {
        'flora_type': flora_name, 'd_flora': int(d_flora), 'dir': aspect_dir, 'dir_tr': translate_dir(aspect_dir, lang), 
        'avg_wind': meteo['avg_wind'], 'wind_dir': wind_code, 'avg_temp': meteo['avg_temp'], 'avg_hum': meteo['avg_hum'],
        'b_count': cnt, 'd_water': int(dw), 's_val': int(slope_pct), 'd_road': int(dr), 'elevation': elevation
    }
    
    res = (int(total), subs, dets)
    try: cache.set(cache_key, res)
    except: pass
    return res

# --- RAPOR OLUŞTURUCU SINIFI ---
class PremiumReport(FPDF):
    def __init__(self, lang='TR'): super().__init__(); self.L = TRANS[lang]
    def header(self):
        self.set_font('Arial','B',12); self.set_text_color(255,193,7); self.cell(0,10,'BeeLocate PRO',0,0,'L')
        self.set_text_color(150); self.set_font('Arial','',9); self.cell(0,10,tr_chars(self.L['footer']),0,0,'R'); self.ln(15)
        self.set_draw_color(220,220,220); self.line(10,22,200,22); self.ln(5)
    def footer(self):
        self.set_y(-15); self.set_font('Arial','I',8); self.set_text_color(128); self.cell(0,10,tr_chars('BeeLocate Systems 2026'),0,0,'C')
    def chapter_title(self, label):
        self.set_font('Arial','B',14); self.set_text_color(40,40,40); self.cell(0,10,tr_chars(label),0,1,'L'); self.ln(2)
    def info_row(self, label, value):
        self.set_font('Arial','B',10); self.set_text_color(100); self.cell(50,8,tr_chars(label),0,0)
        self.set_font('Arial','',10); self.set_text_color(0); self.cell(0,8,tr_chars(str(value)),0,1)

@app.route('/')
def landing(): return render_template('landing.html')

@app.route('/app')
def app_page(): return render_template('index.html')

@app.route('/analyze', methods=['POST'])
def analyze():
    try:
        data = request.json; lang = data.get('lang', 'TR')
        lat, lng, rad = data['lat'], data['lng'], int(data['radius'])
        
        score, subs, dets = calculate_score(lat, lng, rad, lang)
        L = TRANS[lang]
        
        # --- SU DURUMU MANTIĞI (GÜNCELLENDİ) ---
        if dets['d_water'] < 2000:
            water_msg = L['w_good'] + f" ({dets['d_water']}m)"
        elif dets['d_water'] < 5000:
            water_msg = L['w_bad'] + f" ({dets['d_water']}m)"
        else:
            # 5km'den uzaksa artık "Tespit Edilemedi" DEĞİL, "Kritik Uyarı" yazıyor.
            water_msg = L['w_crit']

        wind_txt = L['wi_warn'].format(spd=dets['avg_wind']) if dets['avg_wind'] > 20 else ""
        
        if dets['flora_type'] in ["Bilinmiyor", "Unknown"]:
            ai_text = L['err_summary'].format(wind=dets['dir_tr'], water_txt=water_msg)
        else:
            ai_text = L['std_summary'].format(flora=dets['flora_type'], wind=dets['dir_tr'], water_txt=water_msg, wind_txt=wind_txt)

        grid = []; off = rad/111000
        for i in range(5):
            val = score if i==0 else max(0, min(100, score + np.random.randint(-15, 10)))
            grid.append({'lat': lat + (np.random.random()-0.5)*0.01, 'lng': lng + (np.random.random()-0.5)*0.01, 'val': val})
            
        return jsonify({'score': score, 'breakdown': subs, 'details': dets, 'heatmap': grid, 'ai_text': ai_text})
    except Exception as e:
        print("HATA:", traceback.format_exc())
        return jsonify({'error': str(e)}), 500

@app.route('/download_report')
def download_report():
    try:
        lat = float(request.args.get('lat')); lng = float(request.args.get('lng'))
        rad = int(request.args.get('radius', 2000)); lang = request.args.get('lang', 'TR')
        score, s, d = calculate_score(lat, lng, rad, lang)
        L = TRANS[lang]
        
        pdf = PremiumReport(lang); pdf.add_page()
        pdf.set_font('Arial','B',24); pdf.set_text_color(33,33,33); pdf.cell(0,15,tr_chars(L['title']),0,1,'C'); pdf.ln(5)
        pdf.set_fill_color(255,248,225); pdf.rect(10,pdf.get_y(),190,30,'F'); pdf.set_y(pdf.get_y()+5)
        pdf.set_font('Arial','B',32); pdf.set_text_color(255,143,0); pdf.cell(0,10,f"{score}/100",0,1,'C')
        pdf.set_font('Arial','B',10); pdf.set_text_color(100); pot = L['high'] if score > 70 else L['med']; pdf.cell(0,10,tr_chars(pot),0,1,'C'); pdf.ln(10)

        chart_path = create_radar_chart(s)
        if chart_path: 
            pdf.image(chart_path, x=55, w=100); os.remove(chart_path); pdf.ln(5)

        pdf.chapter_title(L['ch_1']); pdf.set_font('Arial','',10)
        
        # --- PDF İÇİN SU MANTIĞI (SENKRONİZE EDİLDİ) ---
        if d['d_water'] < 2000:
            water_txt = L['w_good'] + f" ({d['d_water']}m)"
        elif d['d_water'] < 5000:
            water_txt = L['w_bad'] + f" ({d['d_water']}m)"
        else:
            water_txt = L['w_crit'] # PDF'te de artık düzgün yazacak

        wind_txt = L['wi_warn'].format(spd=d['avg_wind']) if d['avg_wind'] > 20 else ""
        
        if d['flora_type'] in ["Bilinmiyor", "Unknown"]:
            summary = L['err_summary'].format(wind=tr_chars(d['dir_tr']), water_txt=tr_chars(water_txt))
        else:
            summary = L['std_summary'].format(flora=tr_chars(d['flora_type']), wind=tr_chars(d['dir_tr']), water_txt=tr_chars(water_txt), wind_txt=tr_chars(wind_txt))
            
        pdf.multi_cell(0,6,tr_chars(summary)); pdf.ln(10)

        pdf.chapter_title(L['ch_2'])
        
        # Tablodaki kısa su bilgisi
        w_res = f"{d['d_water']}m" if d['d_water'] < 5000 else tr_chars(">5km (Yetersiz)")
        
        pdf.info_row(L['loc'], f"{lat:.4f}, {lng:.4f}"); pdf.info_row(L['flora'], d['flora_type'])
        pdf.info_row(L['water'], w_res); pdf.info_row(L['wind'], f"{d['avg_wind']} km/h")
        pdf.info_row(L['aspect'], d['dir_tr']); pdf.info_row(L['temp'], f"{d['avg_temp']} C")
        pdf.info_row(L['elev'], f"{d['elevation']}m"); pdf.info_row(L['settle'], f"{d['b_count']}")

        out = pdf.output(dest='S').encode('latin-1'); buf = io.BytesIO(out); buf.seek(0)
        return send_file(buf, as_attachment=True, download_name=f"BeeLocate_{lang}_{lat:.4f}.pdf", mimetype='application/pdf')
    except Exception as e: return str(e), 500

if __name__ == '__main__':
    app.run(debug=True)
